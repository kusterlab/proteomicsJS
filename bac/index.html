<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
	font: 20px sans-serif;
}
    .bar rect {
	    fill: steelblue;
	    shape-rendering: crispEdges;
    }
    .axis path, .axis line {
	    fill: none;
	    stroke: #000;
	    stroke-width: 3px;
	    shape-rendering: crispEdges;
    }
    .line {
	    fill: none;
	    stroke: purple;
	    stroke-width: 1.5px;
    }
    div.tooltip {	
	        position: absolute;			
			    text-align: center;			
				        width: 60px;					
						    height: 28px;					
							        padding: 2px;				
									    font: 12px sans-serif;		
										        background: lightsteelblue;	
												    border: 0px;		
													        border-radius: 8px;			
															    pointer-events: none;			
    }
</style>
<body>
	<script src="//d3js.org/d3.v3.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.1/jstat.min.js"></script>
	<script src="bundle.js"></script>
	<script>
		//Set dimensions
		var m = {top: 50, right: 50, bottom: 50, left: 50}
	, h = 500 - m.top - m.bottom
	, w = 960 - m.left - m.right
	, numBins = 100;

//Using a fixed data set for demo, rather than random generated values
//TODO - update fixed data set later with a larger dataset for demo/testing (and
// feed in via d3.csv() or d3.json() )
def.then(function(dataset){
	var BEST_HIT = 0.9999;
	var CUTOFF = 0.1 ;
	dataset_bac = dataset.map(d=>d);

	dataset = dataset.sort((a, b) => a.similarity - b.similarity);

	dataset = dataset.filter(x=> x.similarity>0 && x.hypothesis== false);
	console.log(dataset);

	var x_min = d3.min(dataset, d=>d.similarity)
	//var xScale = d3.scale.log().domain([1e-2, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	var xScale = d3.scale.log().domain([x_min, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	//var xScale = d3.scale.linear().domain([0, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	var yScaleDensity = d3.scale.linear().domain([0,1]).range([h, 0]); // TODO CALCULATE MINIMU AS min(log(dataset))

	//Axes and scales
	//	ys = { 
	var ticks = d3.range(1, dataset.length + 1)
	// return ticks.map((d) => d / dataset.length) 
	ys=  ticks.map((d) => 1 - d / dataset.length ) 
	//	}
	var ecdf_data = ys.map((el, i) =>
		{ return {
			"x" : dataset[i].similarity,
			"precursorCharge" : dataset[i].precursorCharge,
			"sequence" : dataset[i].sequence,
			"ecdf": el
		}
		});
	var MINIMAL_Y_VALUE = 1e-4;
	var scaleN = dataset.length;
	var ycum = d3.scale.log().domain([MINIMAL_Y_VALUE*scaleN, 1* scaleN]).range([h, 0]);

	const ecdf = d3v4.line()
		.x((d, i) => xScale(dataset[i]))
		.y((d, i) => ycum(ys[i] * scaleN));


	var xAxis = d3.svg.axis()
		.scale(xScale)
		.orient('bottom');


	var yAxis2 = d3.svg.axis()
		.scale(ycum)
		.orient('right');

	//Draw svg
	var svg = d3.select("body").append("svg")
		.attr("width", w + m.left + m.right)
		.attr("height", h + m.top + m.bottom)
		.append("g")
		.attr("transform", "translate(" + m.left + "," + m.top + ")");

	console.log(dataset);
	svg.append("path")
		.datum(dataset)
		.attr("d", ecdf)
		.attr("fill", "none")
		.attr("stroke", "#005293");


	// Function to compute density
	/*
	function kernelDensityEstimator(kernel, X) {
		  return function(V) {
			      return X.map(function(x) {
				            return [x, d3.mean(V, function(v) { return kernel(x - v); })];
				          });
			    };
	}
	function kernelEpanechnikov(k) {
		  return function(v) {
			      return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
			    };
	}
	  // Compute kernel density estimation
	  var kde = kernelDensityEstimator(kernelEpanechnikov(7), xScale.ticks(40));
	  var density =  kde( dataset_bac.map(function(d){  return d; }) )
	console.log(density);

	  svg.append("path")
	      .attr("class", "mypath")
	      .datum(density)
	      .attr("fill", "#69b3a2")
	      .attr("opacity", ".8")
	      .attr("stroke", "#000")
	      .attr("stroke-width", 1)
	      .attr("stroke-linejoin", "round")
	      .attr("d",  d3v4.line()
		              .curve(d3v4.curveBasis)
		                .x(function(d) { return xScale(d[0]); })
		                .y(function(d) { return yScaleDensity(d[1]); })
		            );
*/
	//Draw histogram
	/*
	var bar = svg.selectAll(".bar")
		.data(data)
		.enter().append("g")
		.attr("class", "bar")
		.attr("transform", function(d) { return "translate(" + xScale(d.x) + "," + yhist(d.y) + ")"; });

	bar.append("rect")
		.attr("x", 1)
		.attr("width", w/numBins/1.3)
		.attr("height", function(d) { return h - yhist(d.y); });
	 */
	var div = d3.select("body").append("div")	
	    .attr("class", "tooltip")				
	    .style("opacity", 0);
	
	console.log(ecdf_data);
	ecdf_data = ecdf_data.filter((el) =>{return 0 !== el["ecdf"]})
	console.log(ecdf_data);
	svg.selectAll(".dot")
		.data(ecdf_data)
		.enter()
		.append("circle")
		.attr("class", "dot")
		.style("fill", function(d) { return   ycum(d["ecdf"]* scaleN) < ycum(CUTOFF*scaleN)? "#679A1D":"#E37222AA"   ;}) 
		.attr("cx", function(d) {
			return xScale(d["x"]);
		})
		.attr("cy", function(d) {
			return ycum(d["ecdf"] * scaleN);
		})
		.attr("r", 5)
	        .on("mouseover", function(d) {		
			console.log(d);
			            div.transition()		
			                .duration(200)		
			                .style("opacity", .9);		
			            // div	.html(formatTime(d.date) + "<br/>"  + d.close)	
			            div	.html(d.sequence + "<br/>"  + d.precursorCharge)	
			                .style("left", (d3.event.pageX) + "px")		
			                .style("top", (d3.event.pageY - 28) + "px");	
			            })					
	        .on("mouseout", function(d) {		
			            div.transition()		
			                .duration(500)		
			                .style("opacity", 0);	
			        })
	;

	ecdf_data = ecdf_data.map((el) => {
		el.x_log = Math.log10(el["x"]);
		el.ecdf_log = Math.log10(el["ecdf"]);
		return el;
	});

	var interpolation_data = ecdf_data.filter((el) =>{
		return el.ecdf_log < Math.log10(CUTOFF) && isFinite(el.ecdf_log);
	});


	 var A = interpolation_data.map((el) => {
		 return el["x_log"]
	 }); // of the x-axis
	var b = interpolation_data.map((el) => {
		return el["ecdf_log"] 
	});

	var model = utility.fit_linear_model(A, b);
	var predictor = utility.predict_wrapper(model);

	var predictLine = [Math.log10(CUTOFF), Math.log10(1)].map(x => predictor(x));
	/*
	var predictLine = A.map((el, i) => {
		return {"ecdf_log_predicted": model.coef[1] * el[1] + model.coef[0],
			"x_log": el[1] }
	})*/
	predictLine = predictLine.map((el) => {
			el.x = Math.pow(10, el.x);
			el.ecdf_predicted = Math.pow(10, el.y_predicted);
			return el;

		});


	var guide2 = d3.svg.line()
		.x(function(d){ return xScale(d.x) })
		.y(function(d){ return ycum(d.ecdf_predicted * scaleN) })
		.interpolate('basis');
	var line2 = svg.append('path')
		.datum(predictLine)
		.attr('d', guide2)
		.attr('class', 'interpolation')
		.attr('stroke', "#64A0C8")
		.attr('stroke-width', 4);

	var BEST_HIT = dataset_bac.filter(d=>d.hypothesis===true)[0].similarity;	
	console.log(BEST_HIT);
	console.log(predictor);
	z = ecdf_data.map(d => {
		d.e_value_predicted = Math.pow(10,predictor(Math.log10(d.x))["y_predicted"]);
		return d;
	});
	console.log(z);
	var POINT = [Math.pow(10, predictor(Math.log10(BEST_HIT))["y_predicted"])]
	svg.selectAll(".dotp")
		.data(POINT)
		.enter()
		.append("circle")
		.attr("class", "dot")
		.style("fill", "#C4071B") 
		.attr("cx", function(d) {
			return xScale(BEST_HIT);
		})
		.attr("cy", function(d) {
			return ycum(d * scaleN);
		})
		.attr("r", 5);




	//Draw CDF line
	var guide = d3.svg.line()
		.x(function(d, i){ return xScale(d.x) })
		.interpolate('basis');


	//Draw axes
	svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + h + ")")
		.call(xAxis)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 4)
		.attr("dy", "-.71em")
		.style("text-anchor", "middle")
		.text("Spectral angle");

	svg.append("g")
		.attr("class", "y axis")
		.attr("transform", "translate(" + [w, 0] + ")")
		.call(yAxis2)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 4)
		.attr("dy", "-.71em")
		.style("text-anchor", "end")
		// .text("cdf");
		.text("Expectation value");
});
	</script>
</body>
