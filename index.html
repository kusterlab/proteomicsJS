<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
	font: 10px sans-serif;
}
    .bar rect {
	    fill: steelblue;
	    shape-rendering: crispEdges;
    }
    .axis path, .axis line {
	    fill: none;
	    stroke: #000;
	    shape-rendering: crispEdges;
    }
    .line {
	    fill: none;
	    stroke: purple;
	    stroke-width: 1.5px;
    }
</style>
<body>
	<script src="//d3js.org/d3.v3.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.1/jstat.min.js"></script>
	<script src="bundle.js"></script>
	<script>
		//Set dimensions
		var m = {top: 50, right: 50, bottom: 50, left: 50}
	, h = 500 - m.top - m.bottom
	, w = 960 - m.left - m.right
	, numBins = 100;

//Using a fixed data set for demo, rather than random generated values
//TODO - update fixed data set later with a larger dataset for demo/testing (and
// feed in via d3.csv() or d3.json() )
def.then(function(dataset){
	var BEST_HIT = 0.99
	dataset = dataset.sort((a, b) => a - b);

	var x_min = d3.min(dataset)
	//var xScale = d3.scale.log().domain([1e-2, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	var xScale = d3.scale.log().domain([x_min, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	//var xScale = d3.scale.linear().domain([0, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))

	//Axes and scales
	//	ys = { 
	var ticks = d3.range(1, dataset.length + 1)
	// return ticks.map((d) => d / dataset.length) 
	ys=  ticks.map((d) => 1 - d / dataset.length ) 
	//	}
	var ecdf_data = ys.map((el, i) =>
		{ return {
			"x" : dataset[i],
			"ecdf": el
		}
		});
	var MINIMAL_Y_VALUE = 1e-4;
	var ycum = d3.scale.log().domain([MINIMAL_Y_VALUE, 1]).range([h, 0]);

	const ecdf = d3v4.line()
		.x((d, i) => xScale(dataset[i]))
		.y((d, i) => ycum(ys[i]));


	var xAxis = d3.svg.axis()
		.scale(xScale)
		.orient('bottom');


	var yAxis2 = d3.svg.axis()
		.scale(ycum)
		.orient('right');

	//Draw svg
	var svg = d3.select("body").append("svg")
		.attr("width", w + m.left + m.right)
		.attr("height", h + m.top + m.bottom)
		.append("g")
		.attr("transform", "translate(" + m.left + "," + m.top + ")");

	console.log(dataset);
	svg.append("path")
		.datum(dataset)
		.attr("d", ecdf)
		.attr("fill", "none")
		.attr("stroke", "blue");
	//Draw histogram
	/*
	var bar = svg.selectAll(".bar")
		.data(data)
		.enter().append("g")
		.attr("class", "bar")
		.attr("transform", function(d) { return "translate(" + xScale(d.x) + "," + yhist(d.y) + ")"; });

	bar.append("rect")
		.attr("x", 1)
		.attr("width", w/numBins/1.3)
		.attr("height", function(d) { return h - yhist(d.y); });
	 */
	
	console.log(ecdf_data);
	ecdf_data = ecdf_data.filter((el) =>{return 0 !== el["ecdf"]})
	console.log(ecdf_data);
	var CUTOFF = 0.1
	svg.selectAll(".dot")
		.data(ecdf_data)
		.enter()
		.append("circle")
		.attr("class", "dot")
		.style("fill", function(d) { return   ycum(d["ecdf"]) < ycum(CUTOFF)? "#69b3a2":"rgba(198, 45, 205, 0.8)"   ;}) 
		.attr("cx", function(d) {
			return xScale(d["x"]);
		})
		.attr("cy", function(d) {
			return ycum(d["ecdf"]);
		})
		.attr("r", 5);

	ecdf_data = ecdf_data.map((el) => {
		el.x_log = Math.log10(el["x"]);
		el.ecdf_log = Math.log10(el["ecdf"]);
		return el;
	});

	var interpolation_data = ecdf_data.filter((el) =>{
		return el.ecdf_log < Math.log10(CUTOFF) && isFinite(el.ecdf_log);
	});


	 var A = interpolation_data.map((el) => {
		 return el["x_log"]
	 }); // of the x-axis
	var b = interpolation_data.map((el) => {
		return el["ecdf_log"] 
	});

	var model = utility.fit_linear_model(A, b);
	var predictor = utility.predict_wrapper(model);

	var predictLine = [Math.log10(0.5), Math.log10(1)].map(x => predictor(x));
	/*
	var predictLine = A.map((el, i) => {
		return {"ecdf_log_predicted": model.coef[1] * el[1] + model.coef[0],
			"x_log": el[1] }
	})*/
	predictLine = predictLine.map((el) => {
			el.x = Math.pow(10, el.x);
			el.ecdf_predicted = Math.pow(10, el.y_predicted);
			return el;

		});


	var guide2 = d3.svg.line()
		.x(function(d){ return xScale(d.x) })
		.y(function(d){ return ycum(d.ecdf_predicted) })
		.interpolate('basis');
	var line2 = svg.append('path')
		.datum(predictLine)
		.attr('d', guide2)
		.attr('class', 'interpolation')
		.attr('stroke', "orange")
		.attr('stroke-width', 4);
	
	var POINT = [Math.pow(10, predictor(Math.log10(BEST_HIT))["y_predicted"])]
	svg.selectAll(".dotp")
		.data(POINT)
		.enter()
		.append("circle")
		.attr("class", "dot")
		.style("fill", "red") 
		.attr("cx", function(d) {
			return xScale(BEST_HIT);
		})
		.attr("cy", function(d) {
			return ycum(d);
		})
		.attr("r", 5);




	//Draw CDF line
	var guide = d3.svg.line()
		.x(function(d, i){ return xScale(d.x) })
		.interpolate('basis');


	//Draw axes
	svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + h + ")")
		.call(xAxis);

	svg.append("g")
		.attr("class", "y axis")
		.attr("transform", "translate(" + [w, 0] + ")")
		.call(yAxis2)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 4)
		.attr("dy", "-.71em")
		.style("text-anchor", "end")
		.text("CDF");
});
	</script>
</body>
