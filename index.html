<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
	font: 10px sans-serif;
}
    .bar rect {
	    fill: steelblue;
	    shape-rendering: crispEdges;
    }
    .axis path, .axis line {
	    fill: none;
	    stroke: #000;
	    shape-rendering: crispEdges;
    }
    .line {
	    fill: none;
	    stroke: purple;
	    stroke-width: 1.5px;
    }
</style>
<body>
	<script src="//d3js.org/d3.v3.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.1/jstat.min.js"></script>
	<script src="bundle.js"></script>
	<script>
		//Set dimensions
		var m = {top: 50, right: 50, bottom: 50, left: 50}
	, h = 500 - m.top - m.bottom
	, w = 960 - m.left - m.right
	, numBins = 100;

//Using a fixed data set for demo, rather than random generated values
//TODO - update fixed data set later with a larger dataset for demo/testing (and
// feed in via d3.csv() or d3.json() )
abc.then(function(dataset){
	dataset = dataset.sort((a, b) => a - b);

	console.log(dataset);
	var x_min = console.log(d3.min(dataset))
	var xScale = d3.scale.log().domain([1e-2, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	//var xScale = d3.scale.linear().domain([0, 1]).range([0, w]); // TODO CALCULATE MINIMU AS min(log(dataset))
	var data = d3.layout.histogram().bins(xScale.ticks(numBins))(dataset);
	console.log(data);

	var bandwidth = 0.01;

	function kde(kernel, thresholds, data) {
		return thresholds.map(t => [t, d3.mean(data, d => kernel(t - d))]);
	}
	function epanechnikov(bandwidth) {
		return x => Math.abs(x /= bandwidth) <= 1 ? 0.75 * (1 - x * x) / bandwidth : 0;
	}
	var thresholds = xScale.ticks(numBins);
	console.log(thresholds);
	density = kde(epanechnikov(bandwidth), thresholds, dataset);
	console.log("density");
	console.log(density);
	//	https://www.d3-graph-gallery.com/graph/density_basic.html
	// https://observablehq.com/@d3/kernel-density-estimation
	//	https://stats.stackexchange.com/questions/5819/kernel-density-estimate-takes-values-larger-than-1
	//	PDF can be > 1
	// estimate bandwith https://en.wikipedia.org/wiki/Kernel_density_estimation
	// which kernel https://www.bauer.uh.edu/rsusmel/phd/ec1-26.pdf


	function kernelDensityEstimator(kernel, X) {
		return function(V) {
			return X.map(function(x) {
				return [x, d3.mean(V, function(v) { return kernel(x - v); })];
			});
		};
	}
	function kernelEpanechnikov(k) {
		return function(v) {
			return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
		};
	}

	var kde1 = kernelDensityEstimator(kernelEpanechnikov(0.05), xScale.ticks(numBins))

	var density1 =  kde1( dataset )
	console.log("density1");
	console.log(density1);




	/* now update histogram bins to be cumulative to make cumulative histogram
	 *
	 * FYI: a cumulative histogram is a mapping that counts the cumulative number of
	 * observations in all of the bins up to the specified bin.
	 *
	 * The cumulative bin frequency pattern should roughly match the CDF line?
	 * Can compare with Python's Matplotlib cumulative histogram e.g.
	 * import matplotlib.pyplot as plt
	 * plt.hist(dataset, bins=(0,1,2,3,4,5,6,7,8,9), normed=True, cumulative=True)
	 * plt.title("Cumulative Histogram")
	 * plt.xlabel("Distance")
	 * plt.ylabel("Probability")
	 * plt.savefig("Cumulative Histogram.png", bbox_inches='tight')
	 */

	//for(var i = 1; i < data.length; i++){
	//	data[i].y += data[i-1].y;
	//}

	/* Calculative CDF using jStat - https://github.com/jstat/jstat
	 * We are replicating cumulative distribution/frequency line option that is
	 * available in Excel histograms
	 *
	 * Can validate CDF by calculating each percentile tick/unit (0.1-0.9 or 10-90th
	 * percentiles) against the dataset then comparing the resulting value against
	 * the matching value on the histogram. It should roughly match up if we are
	 * expecting Excel-like output. We can test this assertion by (1) loading same
	 * dataset used with Excel to here using d3.csv() and comparing histograms
	 * between the two, or (2) manually enter this sample dataset here into Excel to
	 * plot a histogram with CDF line then compare the two histograms.
	 */
	var jstat = this.jStat(dataset);
	for(var i=0; i < data.length; i++){
		data[i]['cum'] =  jstat.normal(jstat.mean(), jstat.stdev()).cdf(data[i].x);
	}

	console.log(data);
	//Axes and scales
	//	ys = { 
	var ticks = d3.range(1, dataset.length + 1)
	// return ticks.map((d) => d / dataset.length) 
	ys=  ticks.map((d) => 1 - d / dataset.length) 
	data = data.map((el, i) => {
		el.ecdf = ys[i];
		el.x_more = dataset[i];
		return el;
	});
	//	}
	var ecdf_data = ys.map((el, i) =>
		{ return {
			"x" : dataset[i],
			"ecdf": el
		}
		});
	var yhist = d3.scale.linear()
		.domain([0, d3.max(data, function(d) { return d.y; })])
		.range([h, 0]);
	var MINIMAL_Y_VALUE = 1e-5;
	var ycum = d3.scale.log().domain([MINIMAL_Y_VALUE, 1]).range([h, 0]);

	const ecdf = d3v4.line()
		.x((d, i) => xScale(dataset[i]))
		.y((d, i) => ycum(ys[i]));


	var xAxis = d3.svg.axis()
		.scale(xScale)
		.orient('bottom');

	var yAxis = d3.svg.axis()
		.scale(yhist)
		.orient('left');

	var yAxis2 = d3.svg.axis()
		.scale(ycum)
		.orient('right');

	//Draw svg
	console.log("test");
	var svg = d3.select("body").append("svg")
		.attr("width", w + m.left + m.right)
		.attr("height", h + m.top + m.bottom)
		.append("g")
		.attr("transform", "translate(" + m.left + "," + m.top + ")");

	svg.append("path")
		.datum(dataset)
		.attr("d", ecdf)
		.attr("fill", "none")
		.attr("stroke", "blue");
	console.log("data");
	console.log(data);
	//Draw histogram
	/*
	var bar = svg.selectAll(".bar")
		.data(data)
		.enter().append("g")
		.attr("class", "bar")
		.attr("transform", function(d) { return "translate(" + xScale(d.x) + "," + yhist(d.y) + ")"; });

	bar.append("rect")
		.attr("x", 1)
		.attr("width", w/numBins/1.3)
		.attr("height", function(d) { return h - yhist(d.y); });
	 */
	console.log("ecdf_data");
	console.log(ecdf_data);

	var CUTOFF = 0.1
	svg.selectAll(".dot")
		.data(ecdf_data)
		.enter()
		.append("circle")
		.attr("class", "dot")
		.style("fill", function(d) { return   ycum(d["ecdf"]) < ycum(CUTOFF)? "#69b3a2":"rgba(198, 45, 205, 0.8)"   ;}) 
		.attr("cx", function(d) {
			return xScale(d["x"]);
		})
		.attr("cy", function(d) {
			return ycum(d["ecdf"]);
		})
		.attr("r", 5);

	ecdf_data = ecdf_data.map((el) => {
		el.x_log = Math.log10(el["x"]);
		el.ecdf_log = Math.log10(el["ecdf"]);
		return el;
	});

	var interpolation_data = ecdf_data.filter((el) =>{
		return el.ecdf_log < Math.log10(CUTOFF) && isFinite(el.ecdf_log);
	});

	console.log(ecdf_data);

	console.log("interpolation_data");
	console.log(interpolation_data);
	 var A = interpolation_data.map((el) => {
		 return el["x_log"]
	 }); // of the x-axis
	var b = interpolation_data.map((el) => {
		return el["ecdf_log"] 
	});

	var model = utility.fit_linear_model(A, b);
	var predictor = utility.predict_wrapper(model);

	var predictLine = [Math.log10(0.5), Math.log10(1)].map(x => predictor(x));
	console.log("predictLine_f");
	console.log(predictLine);
	/*
	var predictLine = A.map((el, i) => {
		return {"ecdf_log_predicted": model.coef[1] * el[1] + model.coef[0],
			"x_log": el[1] }
	})*/
	predictLine = predictLine.map((el) => {
			el.x = Math.pow(10, el.x);
			el.ecdf_predicted = Math.pow(10, el.y_predicted);
			return el;

		});
	console.log("predictLine");
	console.log(predictLine);


	var guide2 = d3.svg.line()
		.x(function(d){ return xScale(d.x) })
		.y(function(d){ return ycum(d.ecdf_predicted) })
		.interpolate('basis');

	var line2 = svg.append('path')
		.datum(predictLine)
		.attr('d', guide2)
		.attr('class', 'interpolation')
		.attr('stroke', "orange")
		.attr('stroke-width', 4);
	
	var BEST_HIT = 0.99
	var POINT = [Math.pow(10, predictor(Math.log10(BEST_HIT))["y_predicted"])]
	console.log("POINT");
	console.log(POINT);
	svg.selectAll(".dotp")
		.data(POINT)
		.enter()
		.append("circle")
		.attr("class", "dot")
		.style("fill", "red") 
		.attr("cx", function(d) {
			return xScale(BEST_HIT);
		})
		.attr("cy", function(d) {
			return ycum(d);
		})
		.attr("r", 5);




	//Draw CDF line
	var guide = d3.svg.line()
		.x(function(d, i){ return xScale(d.x) })
		.y(function(d, i){ console.log(ycum(d.cum));return d.cum ===0 ? ycum(1e-9):ycum(d.cum) })
		.interpolate('basis');

	var line = svg.append('path')
		.datum(data)
		.attr('d', guide)
		.attr('class', 'line');

	//Draw axes
	svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + h + ")")
		.call(xAxis);

	svg.append("g")
		.attr("class", "y axis")
		.call(yAxis)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", ".71em")
		.style("text-anchor", "end")
		.text("Count (Histogram)");

	svg.append("g")
		.attr("class", "y axis")
		.attr("transform", "translate(" + [w, 0] + ")")
		.call(yAxis2)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 4)
		.attr("dy", "-.71em")
		.style("text-anchor", "end")
		.text("CDF");
});
	</script>
</body>
